# <p align="center">mysql的理解 </p>

1. 大体来说，MySQL 可以分为 Server 层和存储引擎层
* Server 层包括连接器、查询缓存、分析器、优化器、执行器
* 存储引擎层负责数据的存储和提取。

连接器：管理连接，权限认证
查询缓存：命中的话直接返回结果
分析器：语法分析，词法分析
优化器：执行计划生成，选择索引
执行器：操作引擎，返回结果

存储引擎：存储数据提供读写接口

2. mysql日志 
* MySQL 里面最重要的两个日志，即物理日志 redo log和逻辑日志binlog
* redo log是innodb独有的日志`innodb_flush_log_at_trx_commit` 参数设置为1，每次事务提交后持久化到磁盘   redo log  记录这个页 “做了什么改动”
* `sync_binlog`参数设置为1 ，每次事务提交后持久化到磁盘  Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。
两个人日志两阶段提交，保证恢复数据时，数据的一致性



3. 事务  
* 事务的特性：原子性、一致性、隔离性、持久性
* 多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读
* 事务隔离级别：读未提交、读提交、可重复读、串行化
* 不同事务隔离级别的区别：
    1. 读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到
    2. 读提交：一个事务提交之后，它所做的变更才可以被别的事务看到
    3. 可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的
  4.  串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行
* 配置方法：启动参数`transaction-isolation`
* 事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
* 回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。
* 什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。
* 为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。
* 事务启动方式：
 1. 显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；
 2. set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。
建议使用方法一，如果考虑多一次交互问题，可以使用`commit work and chain`语法。在`autocommit=1`的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行`commit work and chain`则提交事务并自动启动下一个事务。
* 可以查询超过60秒的事务
`select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60`

4. 索引
* 索引的作用：提高数据查询效率
* 常见索引模型：哈希表、有序数组、搜索树
* 哈希表：键 - 值(key - value)。
* 哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
* 哈希冲突的处理办法：链表
* 哈希表适用场景：只有等值查询的场景
* 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
* 有序数组查询效率高，更新效率低
* 有序数组的适用场景：静态存储引擎。
* 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
* 二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
* 数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
* InnoDB中的索引模型：B+Tree
* 索引类型：主键索引、非主键索引
    主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
* 主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)
* 一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
* 从性能和存储空间方面考量，自增主键往往是更合理的选择。



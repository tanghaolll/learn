# <p align="center">mysql的理解 </p>

### 1. 大体来说，MySQL 可以分为 Server 层和存储引擎层
* Server 层包括连接器、查询缓存、分析器、优化器、执行器
* 存储引擎层负责数据的存储和提取。

连接器：管理连接，权限认证
查询缓存：命中的话直接返回结果
分析器：语法分析，词法分析
优化器：执行计划生成，选择索引
执行器：操作引擎，返回结果

存储引擎：存储数据提供读写接口

### 2. mysql日志 
* MySQL 里面最重要的两个日志，即物理日志 redo log和逻辑日志binlog
* redo log是innodb独有的日志`innodb_flush_log_at_trx_commit` 参数设置为1，每次事务提交后持久化到磁盘   redo log  记录这个页 “做了什么改动”
* `sync_binlog`参数设置为1 ，每次事务提交后持久化到磁盘  Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。
两个人日志两阶段提交，保证恢复数据时，数据的一致性



### 3. 事务  
* 事务的特性：原子性、一致性、隔离性、持久性
* 多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读
* 事务隔离级别：读未提交、读提交、可重复读、串行化
* 不同事务隔离级别的区别：
    1. 读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到
    2. 读提交：一个事务提交之后，它所做的变更才可以被别的事务看到
    3. 可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的
  4.  串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行
* 配置方法：启动参数`transaction-isolation`
* 事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
* 回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。
* 什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。
* 为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。
* 事务启动方式：
 1. 显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；
 2. set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。
建议使用方法一，如果考虑多一次交互问题，可以使用`commit work and chain`语法。在`autocommit=1`的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行`commit work and chain`则提交事务并自动启动下一个事务。
* 可以查询超过60秒的事务
`select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60`

### 4. 索引
* 索引的作用：提高数据查询效率
* 常见索引模型：哈希表、有序数组、搜索树
* 哈希表：键 - 值(key - value)。
* 哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
* 哈希冲突的处理办法：链表
* 哈希表适用场景：只有等值查询的场景
* 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
* 有序数组查询效率高，更新效率低
* 有序数组的适用场景：静态存储引擎。
* 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
* 二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
* 数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
* InnoDB中的索引模型：B+Tree
* 索引类型：主键索引、非主键索引
    主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
* 主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)
* 一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
* 从性能和存储空间方面考量，自增主键往往是更合理的选择。

* 覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据
* 最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符
* 联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
* 索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

### 5. 全局锁和表锁
* 根据加锁范围：MySQL里面的锁可以分为：全局锁、表级锁、行级锁
* 全局锁：
对整个数据库实例加锁。
MySQL提供加全局读锁的方法：`Flush tables with read lock(FTWRL)`
这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。
使用场景：全库逻辑备份。
风险：
1.如果在主库备份，在备份期间不能更新，业务停摆
2.如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟
官方自带的逻辑备份工具mysqldump，当mysqldump使用参数--single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
一致性读是好，但是前提是引擎要支持这个隔离级别。
如果要全库只读，为什么不使用set global readonly=true的方式？
1.在有些系统中，readonly的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。
2.在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。
* 表级锁
MySQL里面表级锁有两种，一种是表锁，一种是元数据所(meta data lock,MDL)
表锁的语法是:lock tables ... read/write
可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。
MDL：不需要显式使用，在访问一个表的时候会被自动加上。
MDL的作用：保证读写的正确性。
在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
读锁之间不互斥。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。
MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。

### 6. 行锁
* 两阶段锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放， 而是要等到事务结束时才释放。
* 建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
* 死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态。
解决方案：
*  通过参数 innodb_lock_wait_timeout 根据实际业务场景来设置超时时间，InnoDB引擎默认值是50s。
* 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）。
* 如何解决热点行更新导致的性能问题？
* 如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用
*  控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。
* 将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。
* innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。

### 7. 事务是否需要隔离

* 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读
* 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
* 对于读提交，查询只承认在语句启动前就已经提交完成的数据；






